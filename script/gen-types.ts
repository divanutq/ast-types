import fs from "fs";
import path from "path";
import { prettyPrint } from "recast";
import astTypes from "../main";

const { builders: b, getBuilderName, createTSTypeAnnotator } = astTypes;

const { getTSTypeAnnotation, getTSPropertySignature } = createTSTypeAnnotator({
  getReferenceToKind(typeName) {
    // TODO Make this work even if TypeScript types not used?
    return b.tsTypeReference(b.tsQualifiedName(b.identifier("K"), b.identifier(`${typeName}Kind`)));
  },
});

const RESERVED: { [reserved: string]: boolean | undefined } = {
  extends: true,
  default: true,
  arguments: true,
  static: true,
};

const supertypeToSubtypes: { [supertypeName: string]: string[] } = {};
Object.keys(astTypes.namedTypes).map(typeName => {
  astTypes.Type.def(typeName).supertypeList.forEach(supertypeName => {
    supertypeToSubtypes[supertypeName] = supertypeToSubtypes[supertypeName] || [];
    supertypeToSubtypes[supertypeName].push(typeName);
  });
});

const builderTypeNames = Object.keys(astTypes.namedTypes).filter(typeName => {
  const typeDef = astTypes.Type.def(typeName);
  const builderName = getBuilderName(typeName);

  return !!typeDef.buildParams && !!(astTypes.builders as any)[builderName];
});

const createModule = (body: any[]) =>
  b.file.from({
    comments: [b.commentBlock(" !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!! ")],
    program: b.program(body),
  });

const importFromKinds = () =>
  b.importDeclaration.from({
    specifiers: [
      b.importNamespaceSpecifier.from({
        local: b.identifier("K"),
      }),
    ],
    source: b.stringLiteral("./kinds"),
  });

const importFromNodes = () =>
  b.importDeclaration.from({
    specifiers: [
      b.importNamespaceSpecifier.from({
        local: b.identifier("N"),
      }),
    ],
    source: b.stringLiteral("./nodes"),
  });

const out = [
  {
    file: "kinds.ts",
    ast: createModule([
      importFromNodes(),
      ...Object.keys(supertypeToSubtypes).map(baseName => {
        return b.exportNamedDeclaration(
          b.tsTypeAliasDeclaration.from({
            id: b.identifier(`${baseName}Kind`),
            typeAnnotation: b.tsUnionType(
              supertypeToSubtypes[baseName].map(subtypeName =>
                b.tsTypeReference(b.tsQualifiedName(b.identifier("N"), b.identifier(subtypeName)))
              )
            ),
          })
        );
      }),
    ]),
  },
  {
    file: "nodes.ts",
    ast: createModule([
      b.importDeclaration.from({
        specifiers: [b.importSpecifier(b.identifier("Omit"))],
        source: b.stringLiteral("../types"),
      }),
      importFromKinds(),
      ...Object.keys(astTypes.namedTypes).map(typeName => {
        const typeDef = astTypes.Type.def(typeName);
        const fieldNames = Object.keys({ type: true, ...typeDef.ownFields })
          .filter(fieldName => !!typeDef.allFields[fieldName]);

        return b.exportNamedDeclaration(
          b.tsInterfaceDeclaration.from({
            id: b.identifier(typeName),
            extends: typeDef.baseNames.map(baseName => {
              const baseDef = astTypes.Type.def(baseName);
              const commonFieldNames = fieldNames.filter(fieldName => !!baseDef.allFields[fieldName]);

              if (commonFieldNames.length > 0) {
                return b.tsExpressionWithTypeArguments(
                  b.identifier("Omit"),
                  b.tsTypeParameterInstantiation([
                    b.tsTypeReference(b.identifier(baseName)),
                    b.tsUnionType(commonFieldNames.map(fieldName => {
                      return b.tsLiteralType(b.stringLiteral(fieldName));
                    })),
                  ])
                );
              } else {
                return b.tsExpressionWithTypeArguments(b.identifier(baseName));
              }
            }),
            body: b.tsInterfaceBody.from({
              body: fieldNames.map(fieldName => {
                if (fieldName === "type") {
                  return b.tsPropertySignature.from({
                    key: b.identifier("type"),
                    typeAnnotation: b.tsTypeAnnotation(b.tsLiteralType(b.stringLiteral(typeName))),
                  });
                }

                const field = typeDef.allFields[fieldName];
                return getTSPropertySignature(field);
              }),
            }),
          })
        );
      }),
    ]),
  },
  {
    file: "namedTypes.ts",
    ast: createModule([
      b.importDeclaration.from({
        specifiers: [b.importSpecifier(b.identifier("Type"))],
        source: b.stringLiteral("../lib/types"),
      }),
      importFromNodes(),
      b.exportNamedDeclaration(
        b.tsInterfaceDeclaration.from({
          id: b.identifier("NamedTypes"),
          body: b.tsInterfaceBody.from({
            body: Object.keys(astTypes.namedTypes).map(typeName => {
              return b.tsPropertySignature.from({
                key: b.identifier(typeName),
                typeAnnotation: b.tsTypeAnnotation.from({
                  typeAnnotation: b.tsTypeReference.from({
                    typeName: b.identifier("Type"),
                    typeParameters: b.tsTypeParameterInstantiation([
                      b.tsTypeReference(
                        b.tsQualifiedName(b.identifier("N"), b.identifier(typeName))
                      ),
                    ]),
                  }),
                }),
              });
            }),
          }),
        })
      ),
    ]),
  },
  {
    file: "builders.ts",
    ast: createModule([
      importFromKinds(),
      importFromNodes(),
      ...builderTypeNames.map(typeName => {
        const typeDef = astTypes.Type.def(typeName);

        const returnType = b.tsTypeAnnotation.from({
          typeAnnotation: b.tsTypeReference.from({
            typeName: b.tsQualifiedName.from({
              left: b.identifier("N"),
              right: b.identifier(typeName),
            }),
          }),
        });

        const buildParamAllowsUndefined: { [buildParam: string]: boolean } = {};
        const buildParamIsOptional: { [buildParam: string]: boolean } = {};
        [...typeDef.buildParams].reverse().forEach((cur, i, arr) => {
          const field = typeDef.allFields[cur];
          if (field && field.defaultFn) {
            if (i === 0) {
              buildParamIsOptional[cur] = true;
            } else {
              if (buildParamIsOptional[arr[i - 1]]) {
                buildParamIsOptional[cur] = true;
              } else {
                buildParamAllowsUndefined[cur] = true;
              }
            }
          }
        });

        return b.exportNamedDeclaration(
          b.tsInterfaceDeclaration.from({
            id: b.identifier(`${typeName}Builder`),
            body: b.tsInterfaceBody.from({
              body: [
                b.tsCallSignatureDeclaration.from({
                  parameters: typeDef.buildParams
                    .filter(buildParam => !!typeDef.allFields[buildParam])
                    .map(buildParam => {
                      const field = typeDef.allFields[buildParam];
                      const name = RESERVED[buildParam] ? `${buildParam}Param` : buildParam;

                      return b.identifier.from({
                        name,
                        typeAnnotation: b.tsTypeAnnotation(
                          !!buildParamAllowsUndefined[buildParam]
                            ? b.tsUnionType([
                                getTSTypeAnnotation(field.type),
                                b.tsUndefinedKeyword(),
                              ])
                            : getTSTypeAnnotation(field.type)
                        ),
                        optional: !!buildParamIsOptional[buildParam],
                      });
                    }),
                  typeAnnotation: returnType,
                }),
                b.tsMethodSignature.from({
                  key: b.identifier("from"),
                  parameters: [
                    b.identifier.from({
                      name: "params",
                      typeAnnotation: b.tsTypeAnnotation.from({
                        typeAnnotation: b.tsTypeLiteral.from({
                          members: Object.keys(typeDef.allFields)
                            .filter(fieldName => fieldName !== "type")
                            .sort() // Sort field name strings lexicographically.
                            .map(fieldName => {
                              return getTSPropertySignature(typeDef.allFields[fieldName]);
                            }),
                        }),
                      }),
                    }),
                  ],
                  typeAnnotation: returnType,
                }),
              ],
            }),
          })
        );
      }),

      b.exportNamedDeclaration(
        b.tsInterfaceDeclaration.from({
          id: b.identifier("Builders"),
          body: b.tsInterfaceBody([
            ...builderTypeNames.map(typeName =>
              b.tsPropertySignature.from({
                key: b.identifier(getBuilderName(typeName)),
                typeAnnotation: b.tsTypeAnnotation.from({
                  typeAnnotation: b.tsTypeReference.from({
                    typeName: b.identifier(`${typeName}Builder`),
                  }),
                }),
              })
            ),
            b.tsIndexSignature.from({
              parameters: [
                b.identifier.from({
                  name: "builderName",
                  typeAnnotation: b.tsTypeAnnotation(b.tsStringKeyword()),
                }),
              ],
              typeAnnotation: b.tsTypeAnnotation.from({ typeAnnotation: b.tsAnyKeyword() }),
            }),
          ]),
        })
      ),
    ]),
  },
  {
    file: "visitor.ts",
    ast: createModule([
      b.importDeclaration(
        [b.importSpecifier(b.identifier("NodePath"))],
        b.stringLiteral("../lib/node-path")
      ),
      b.importDeclaration(
        [b.importSpecifier(b.identifier("Context"))],
        b.stringLiteral("../lib/path-visitor")
      ),
      importFromNodes(),
      b.exportNamedDeclaration(
        b.tsInterfaceDeclaration.from({
          id: b.identifier("Visitor"),
          typeParameters: b.tsTypeParameterDeclaration([
            b.tsTypeParameter("M", undefined, b.tsTypeLiteral([])),
          ]),
          body: b.tsInterfaceBody([
            ...Object.keys(astTypes.namedTypes).map(typeName => {
              return b.tsMethodSignature.from({
                key: b.identifier(`visit${typeName}`),
                parameters: [
                  b.identifier.from({
                    name: "this",
                    typeAnnotation: b.tsTypeAnnotation(
                      b.tsIntersectionType([
                        b.tsTypeReference(b.identifier("Context")),
                        b.tsTypeReference(b.identifier("M")),
                      ])
                    ),
                  }),
                  b.identifier.from({
                    name: "path",
                    typeAnnotation: b.tsTypeAnnotation(
                      b.tsTypeReference(
                        b.identifier("NodePath"),
                        b.tsTypeParameterInstantiation([
                          b.tsTypeReference(
                            b.tsQualifiedName(b.identifier("N"), b.identifier(typeName))
                          ),
                        ])
                      )
                    ),
                  }),
                ],
                optional: true,
                typeAnnotation: b.tsTypeAnnotation(b.tsAnyKeyword()),
              });
            }),
          ]),
        })
      ),
    ]),
  },
];

out.forEach(({ file, ast }) => {
  fs.writeFileSync(
    path.resolve(__dirname, `../gen/${file}`),
    prettyPrint(ast, { tabWidth: 2, includeComments: true }).code
  );
});
