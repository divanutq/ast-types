/* !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!! */
import * as K from "./kinds";
export interface Printable {}

export interface SourceLocation {
  type: "SourceLocation";
  start: K.PositionKind;
  end: K.PositionKind;
  source?: string | null;
}

export interface Node {
  type: "Node";
}

export interface Comment {
  value: string;
  leading: boolean;
  trailing: boolean;
}

export interface Position {
  type: "Position";
  line: number;
  column: number;
}

export interface File {
  type: "File";
  program: K.ProgramKind;
  name?: string | null;
}

export interface Program {
  type: "Program";
  body: K.StatementKind[];
  directives: K.DirectiveKind[];
}

export interface Statement {
  type: "Statement";
}

export interface Function {
  type: "Function";
  id?: K.IdentifierKind | null;
  params: K.PatternKind[];
  body: K.BlockStatementKind | K.ExpressionKind;
  generator: boolean;
  expression: boolean;
  defaults: (K.ExpressionKind | null)[];
  rest?: K.IdentifierKind | null;
  async: boolean;
  returnType?: K.TypeAnnotationKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
}

export interface Pattern {
  type: "Pattern";
}

export interface Expression {
  type: "Expression";
}

export interface Identifier {
  type: "Identifier";
  name: string;
  optional: boolean;
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
}

export interface BlockStatement {
  type: "BlockStatement";
  body: K.StatementKind[];
  directives: K.DirectiveKind[];
}

export interface EmptyStatement {
  type: "EmptyStatement";
}

export interface ExpressionStatement {
  type: "ExpressionStatement";
  expression: K.ExpressionKind;
}

export interface IfStatement {
  type: "IfStatement";
  test: K.ExpressionKind;
  consequent: K.StatementKind;
  alternate?: K.StatementKind | null;
}

export interface LabeledStatement {
  type: "LabeledStatement";
  label: K.IdentifierKind;
  body: K.StatementKind;
}

export interface BreakStatement {
  type: "BreakStatement";
  label?: K.IdentifierKind | null;
}

export interface ContinueStatement {
  type: "ContinueStatement";
  label?: K.IdentifierKind | null;
}

export interface WithStatement {
  type: "WithStatement";
  object: K.ExpressionKind;
  body: K.StatementKind;
}

export interface SwitchStatement {
  type: "SwitchStatement";
  discriminant: K.ExpressionKind;
  cases: K.SwitchCaseKind[];
  lexical: boolean;
}

export interface SwitchCase {
  type: "SwitchCase";
  test?: K.ExpressionKind | null;
  consequent: K.StatementKind[];
}

export interface ReturnStatement {
  type: "ReturnStatement";
  argument?: K.ExpressionKind | null;
}

export interface ThrowStatement {
  type: "ThrowStatement";
  argument: K.ExpressionKind;
}

export interface TryStatement {
  type: "TryStatement";
  block: K.BlockStatementKind;
  handler?: K.CatchClauseKind | null;
  guardedHandlers: K.CatchClauseKind[];
  finalizer?: K.BlockStatementKind | null;
}

export interface CatchClause {
  type: "CatchClause";
  param?: K.PatternKind | null;
  guard?: K.ExpressionKind | null;
  body: K.BlockStatementKind;
}

export interface WhileStatement {
  type: "WhileStatement";
  test: K.ExpressionKind;
  body: K.StatementKind;
}

export interface DoWhileStatement {
  type: "DoWhileStatement";
  body: K.StatementKind;
  test: K.ExpressionKind;
}

export interface ForStatement {
  type: "ForStatement";
  init?: K.VariableDeclarationKind | K.ExpressionKind | null;
  test?: K.ExpressionKind | null;
  update?: K.ExpressionKind | null;
  body: K.StatementKind;
}

export interface Declaration {
  type: "Declaration";
}

export interface VariableDeclaration {
  type: "VariableDeclaration";
  kind: "var" | "let" | "const";
  declarations: (K.VariableDeclaratorKind | K.IdentifierKind)[];
}

export interface ForInStatement {
  type: "ForInStatement";
  left: K.VariableDeclarationKind | K.ExpressionKind;
  right: K.ExpressionKind;
  body: K.StatementKind;
  each: boolean;
}

export interface DebuggerStatement {
  type: "DebuggerStatement";
}

export interface FunctionDeclaration {
  type: "FunctionDeclaration";
  id: K.IdentifierKind;
  params: K.PatternKind[];
  body: K.BlockStatementKind | K.ExpressionKind;
  generator: boolean;
  expression: boolean;
  defaults: (K.ExpressionKind | null)[];
  rest?: K.IdentifierKind | null;
  async: boolean;
  returnType?: K.TypeAnnotationKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
}

export interface FunctionExpression {
  type: "FunctionExpression";
  id?: K.IdentifierKind | null;
  params: K.PatternKind[];
  body: K.BlockStatementKind | K.ExpressionKind;
  generator: boolean;
  expression: boolean;
  defaults: (K.ExpressionKind | null)[];
  rest?: K.IdentifierKind | null;
  async: boolean;
  returnType?: K.TypeAnnotationKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
}

export interface VariableDeclarator {
  type: "VariableDeclarator";
  id: K.PatternKind;
  init?: K.ExpressionKind | null;
}

export interface ThisExpression {
  type: "ThisExpression";
}

export interface ArrayExpression {
  type: "ArrayExpression";
  elements: (K.ExpressionKind | K.SpreadElementKind | K.RestElementKind | null)[];
}

export interface ObjectExpression {
  type: "ObjectExpression";
  properties: (K.PropertyKind | K.ObjectMethodKind | K.ObjectPropertyKind | K.SpreadPropertyKind | K.SpreadElementKind)[];
}

export interface Property {
  type: "Property";
  kind: "init" | "get" | "set";
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
  value: K.ExpressionKind | K.PatternKind;
  method: boolean;
  shorthand: boolean;
  computed: boolean;
  decorators?: K.DecoratorKind[] | null;
}

export interface Literal {
  type: "Literal";
  value?: string | boolean | null | number | RegExp;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
}

export interface SequenceExpression {
  type: "SequenceExpression";
  expressions: K.ExpressionKind[];
}

export interface UnaryExpression {
  type: "UnaryExpression";
  operator: "-" | "+" | "!" | "~" | "typeof" | "void" | "delete";
  argument: K.ExpressionKind;
  prefix: boolean;
}

export interface BinaryExpression {
  type: "BinaryExpression";
  operator: "==" | "!=" | "===" | "!==" | "<" | "<=" | ">" | ">=" | "<<" | ">>" | ">>>" | "+" | "-" | "*" | "/" | "%" | "**" | "&" | "|" | "^" | "in" | "instanceof" | "..";
  left: K.ExpressionKind;
  right: K.ExpressionKind;
}

export interface AssignmentExpression {
  type: "AssignmentExpression";
  operator: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "^=" | "&=";
  left: K.PatternKind;
  right: K.ExpressionKind;
}

export interface UpdateExpression {
  type: "UpdateExpression";
  operator: "++" | "--";
  argument: K.ExpressionKind;
  prefix: boolean;
}

export interface LogicalExpression {
  type: "LogicalExpression";
  operator: "||" | "&&" | "??";
  left: K.ExpressionKind;
  right: K.ExpressionKind;
}

export interface ConditionalExpression {
  type: "ConditionalExpression";
  test: K.ExpressionKind;
  consequent: K.ExpressionKind;
  alternate: K.ExpressionKind;
}

export interface NewExpression {
  type: "NewExpression";
  callee: K.ExpressionKind;
  arguments: (K.ExpressionKind | K.SpreadElementKind)[];
}

export interface CallExpression {
  type: "CallExpression";
  callee: K.ExpressionKind;
  arguments: (K.ExpressionKind | K.SpreadElementKind)[];
}

export interface MemberExpression {
  type: "MemberExpression";
  object: K.ExpressionKind;
  property: K.IdentifierKind | K.ExpressionKind;
  computed: boolean;
}

export interface RestElement {
  type: "RestElement";
  argument: K.PatternKind;
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
}

export interface TypeAnnotation {
  type: "TypeAnnotation";
  typeAnnotation: K.FlowTypeKind;
}

export interface TSTypeAnnotation {
  type: "TSTypeAnnotation";
  typeAnnotation: K.TSTypeKind | K.TSTypeAnnotationKind;
}

export interface SpreadElementPattern {
  type: "SpreadElementPattern";
  argument: K.PatternKind;
}

export interface ArrowFunctionExpression {
  type: "ArrowFunctionExpression";
  id?: null;
  params: K.PatternKind[];
  body: K.BlockStatementKind | K.ExpressionKind;
  generator: false;
  expression: boolean;
  defaults: (K.ExpressionKind | null)[];
  rest?: K.IdentifierKind | null;
  async: boolean;
  returnType?: K.TypeAnnotationKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
}

export interface ForOfStatement {
  type: "ForOfStatement";
  left: K.VariableDeclarationKind | K.PatternKind;
  right: K.ExpressionKind;
  body: K.StatementKind;
}

export interface YieldExpression {
  type: "YieldExpression";
  argument?: K.ExpressionKind | null;
  delegate: boolean;
}

export interface GeneratorExpression {
  type: "GeneratorExpression";
  body: K.ExpressionKind;
  blocks: K.ComprehensionBlockKind[];
  filter?: K.ExpressionKind | null;
}

export interface ComprehensionBlock {
  type: "ComprehensionBlock";
  left: K.PatternKind;
  right: K.ExpressionKind;
  each: boolean;
}

export interface ComprehensionExpression {
  type: "ComprehensionExpression";
  body: K.ExpressionKind;
  blocks: K.ComprehensionBlockKind[];
  filter?: K.ExpressionKind | null;
}

export interface PropertyPattern {
  type: "PropertyPattern";
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
  pattern: K.PatternKind;
  computed: boolean;
}

export interface ObjectPattern {
  type: "ObjectPattern";
  properties: (K.PropertyKind | K.PropertyPatternKind | K.SpreadPropertyPatternKind | K.SpreadPropertyKind | K.ObjectPropertyKind | K.RestPropertyKind)[];
  typeAnnotation?: K.TypeAnnotationKind | null;
  decorators?: K.DecoratorKind[] | null;
}

export interface ArrayPattern {
  type: "ArrayPattern";
  elements: (K.PatternKind | K.SpreadElementKind | null)[];
}

export interface MethodDefinition {
  type: "MethodDefinition";
  kind: "constructor" | "method" | "get" | "set";
  key: K.ExpressionKind;
  value: K.FunctionKind;
  computed: boolean;
  static: boolean;
  decorators?: K.DecoratorKind[] | null;
}

export interface SpreadElement {
  type: "SpreadElement";
  argument: K.ExpressionKind;
}

export interface AssignmentPattern {
  type: "AssignmentPattern";
  left: K.PatternKind;
  right: K.ExpressionKind;
}

export interface ClassPropertyDefinition {
  type: "ClassPropertyDefinition";
  definition: K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind;
}

export interface ClassProperty {
  type: "ClassProperty";
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
  computed: boolean;
  value?: K.ExpressionKind | null;
  typeAnnotation?: K.TypeAnnotationKind | null;
  static: boolean;
  variance?: K.VarianceKind | "plus" | "minus" | null;
}

export interface ClassBody {
  type: "ClassBody";
  body: (K.MethodDefinitionKind | K.VariableDeclaratorKind | K.ClassPropertyDefinitionKind | K.ClassPropertyKind | K.ClassMethodKind | K.TSDeclareMethodKind | K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
}

export interface ClassDeclaration {
  type: "ClassDeclaration";
  id?: K.IdentifierKind | null;
  body: K.ClassBodyKind;
  superClass?: K.ExpressionKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  superTypeParameters?: K.GenericTypeAnnotationKind[] | null;
  implements: K.TSExpressionWithTypeArgumentsKind[];
}

export interface ClassExpression {
  type: "ClassExpression";
  id?: K.IdentifierKind | null;
  body: K.ClassBodyKind;
  superClass?: K.ExpressionKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  superTypeParameters?: K.GenericTypeAnnotationKind[] | null;
  implements: K.TSExpressionWithTypeArgumentsKind[];
}

export interface Specifier {
  type: "Specifier";
}

export interface ModuleSpecifier {
  type: "ModuleSpecifier";
  local?: K.IdentifierKind | null;
  id?: K.IdentifierKind | null;
  name?: K.IdentifierKind | null;
}

export interface ImportSpecifier {
  type: "ImportSpecifier";
  local?: K.IdentifierKind | null;
  id?: K.IdentifierKind | null;
  name?: K.IdentifierKind | null;
  imported: K.IdentifierKind;
}

export interface ImportNamespaceSpecifier {
  type: "ImportNamespaceSpecifier";
  local?: K.IdentifierKind | null;
  id?: K.IdentifierKind | null;
  name?: K.IdentifierKind | null;
}

export interface ImportDefaultSpecifier {
  type: "ImportDefaultSpecifier";
  local?: K.IdentifierKind | null;
  id?: K.IdentifierKind | null;
  name?: K.IdentifierKind | null;
}

export interface ImportDeclaration {
  type: "ImportDeclaration";
  specifiers: (K.ImportSpecifierKind | K.ImportNamespaceSpecifierKind | K.ImportDefaultSpecifierKind)[];
  source: K.LiteralKind;
  importKind: "value" | "type";
}

export interface TaggedTemplateExpression {
  type: "TaggedTemplateExpression";
  tag: K.ExpressionKind;
  quasi: K.TemplateLiteralKind;
}

export interface TemplateLiteral {
  type: "TemplateLiteral";
  quasis: K.TemplateElementKind[];
  expressions: K.ExpressionKind[];
}

export interface TemplateElement {
  type: "TemplateElement";
  value: {
    "cooked": string,
    "raw": string
  };
  tail: boolean;
}

export interface SpreadProperty {
  type: "SpreadProperty";
  argument: K.ExpressionKind;
}

export interface SpreadPropertyPattern {
  type: "SpreadPropertyPattern";
  argument: K.PatternKind;
}

export interface AwaitExpression {
  type: "AwaitExpression";
  argument?: K.ExpressionKind | null;
  all: boolean;
}

export interface LetStatement {
  type: "LetStatement";
  head: K.VariableDeclaratorKind[];
  body: K.StatementKind;
}

export interface LetExpression {
  type: "LetExpression";
  head: K.VariableDeclaratorKind[];
  body: K.ExpressionKind;
}

export interface GraphExpression {
  type: "GraphExpression";
  index: number;
  expression: K.LiteralKind;
}

export interface GraphIndexExpression {
  type: "GraphIndexExpression";
  index: number;
}

export interface XMLDefaultDeclaration {
  type: "XMLDefaultDeclaration";
  namespace: K.ExpressionKind;
}

export interface XMLAnyName {
  type: "XMLAnyName";
}

export interface XMLQualifiedIdentifier {
  type: "XMLQualifiedIdentifier";
  left: K.IdentifierKind | K.XMLAnyNameKind;
  right: K.IdentifierKind | K.ExpressionKind;
  computed: boolean;
}

export interface XMLFunctionQualifiedIdentifier {
  type: "XMLFunctionQualifiedIdentifier";
  right: K.IdentifierKind | K.ExpressionKind;
  computed: boolean;
}

export interface XMLAttributeSelector {
  type: "XMLAttributeSelector";
  attribute: K.ExpressionKind;
}

export interface XMLFilterExpression {
  type: "XMLFilterExpression";
  left: K.ExpressionKind;
  right: K.ExpressionKind;
}

export interface XML {
  type: "XML";
}

export interface XMLElement {
  type: "XMLElement";
  contents: K.XMLKind[];
}

export interface XMLList {
  type: "XMLList";
  contents: K.XMLKind[];
}

export interface XMLEscape {
  type: "XMLEscape";
  expression: K.ExpressionKind;
}

export interface XMLText {
  type: "XMLText";
  text: string;
}

export interface XMLStartTag {
  type: "XMLStartTag";
  contents: K.XMLKind[];
}

export interface XMLEndTag {
  type: "XMLEndTag";
  contents: K.XMLKind[];
}

export interface XMLPointTag {
  type: "XMLPointTag";
  contents: K.XMLKind[];
}

export interface XMLName {
  type: "XMLName";
  contents: string | K.XMLKind[];
}

export interface XMLAttribute {
  type: "XMLAttribute";
  value: string;
}

export interface XMLCdata {
  type: "XMLCdata";
  contents: string;
}

export interface XMLComment {
  type: "XMLComment";
  contents: string;
}

export interface XMLProcessingInstruction {
  type: "XMLProcessingInstruction";
  target: string;
  contents?: string | null;
}

export interface JSXAttribute {
  type: "JSXAttribute";
  name: K.JSXIdentifierKind | K.JSXNamespacedNameKind;
  value?: K.LiteralKind | K.JSXExpressionContainerKind | null;
}

export interface JSXIdentifier {
  type: "JSXIdentifier";
  name: string;
  optional: boolean;
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
}

export interface JSXNamespacedName {
  type: "JSXNamespacedName";
  namespace: K.JSXIdentifierKind;
  name: K.JSXIdentifierKind;
}

export interface JSXExpressionContainer {
  type: "JSXExpressionContainer";
  expression: K.ExpressionKind;
}

export interface JSXMemberExpression {
  type: "JSXMemberExpression";
  object: K.JSXIdentifierKind | K.JSXMemberExpressionKind;
  property: K.JSXIdentifierKind;
  computed: boolean;
}

export interface JSXSpreadAttribute {
  type: "JSXSpreadAttribute";
  argument: K.ExpressionKind;
}

export interface JSXElement {
  type: "JSXElement";
  openingElement: K.JSXOpeningElementKind;
  closingElement?: K.JSXClosingElementKind | null;
  children: (K.JSXElementKind | K.JSXExpressionContainerKind | K.JSXFragmentKind | K.JSXTextKind | K.LiteralKind)[];
}

export interface JSXOpeningElement {
  type: "JSXOpeningElement";
  name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
  attributes: (K.JSXAttributeKind | K.JSXSpreadAttributeKind)[];
  selfClosing: boolean;
}

export interface JSXClosingElement {
  type: "JSXClosingElement";
  name: K.JSXIdentifierKind | K.JSXNamespacedNameKind | K.JSXMemberExpressionKind;
}

export interface JSXFragment {
  type: "JSXFragment";
  openingElement: K.JSXOpeningFragmentKind;
  closingElement: K.JSXClosingFragmentKind;
  children: (K.JSXElementKind | K.JSXExpressionContainerKind | K.JSXFragmentKind | K.JSXTextKind | K.LiteralKind)[];
}

export interface JSXText {
  type: "JSXText";
  value: string;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
}

export interface JSXOpeningFragment {
  type: "JSXOpeningFragment";
}

export interface JSXClosingFragment {
  type: "JSXClosingFragment";
}

export interface JSXEmptyExpression {
  type: "JSXEmptyExpression";
}

export interface JSXSpreadChild {
  type: "JSXSpreadChild";
  expression: K.ExpressionKind;
}

export interface Flow {
  type: "Flow";
}

export interface FlowType {
  type: "FlowType";
}

export interface AnyTypeAnnotation {
  type: "AnyTypeAnnotation";
}

export interface EmptyTypeAnnotation {
  type: "EmptyTypeAnnotation";
}

export interface MixedTypeAnnotation {
  type: "MixedTypeAnnotation";
}

export interface VoidTypeAnnotation {
  type: "VoidTypeAnnotation";
}

export interface NumberTypeAnnotation {
  type: "NumberTypeAnnotation";
}

export interface NumberLiteralTypeAnnotation {
  type: "NumberLiteralTypeAnnotation";
  value: number;
  raw: string;
}

export interface NumericLiteralTypeAnnotation {
  type: "NumericLiteralTypeAnnotation";
  value: number;
  raw: string;
}

export interface StringTypeAnnotation {
  type: "StringTypeAnnotation";
}

export interface StringLiteralTypeAnnotation {
  type: "StringLiteralTypeAnnotation";
  value: string;
  raw: string;
}

export interface BooleanTypeAnnotation {
  type: "BooleanTypeAnnotation";
}

export interface BooleanLiteralTypeAnnotation {
  type: "BooleanLiteralTypeAnnotation";
  value: boolean;
  raw: string;
}

export interface NullableTypeAnnotation {
  type: "NullableTypeAnnotation";
  typeAnnotation: K.FlowTypeKind;
}

export interface NullLiteralTypeAnnotation {
  type: "NullLiteralTypeAnnotation";
}

export interface NullTypeAnnotation {
  type: "NullTypeAnnotation";
}

export interface ThisTypeAnnotation {
  type: "ThisTypeAnnotation";
}

export interface ExistsTypeAnnotation {
  type: "ExistsTypeAnnotation";
}

export interface ExistentialTypeParam {
  type: "ExistentialTypeParam";
}

export interface FunctionTypeAnnotation {
  type: "FunctionTypeAnnotation";
  params: K.FunctionTypeParamKind[];
  returnType: K.FlowTypeKind;
  rest?: K.FunctionTypeParamKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
}

export interface FunctionTypeParam {
  type: "FunctionTypeParam";
  name: K.IdentifierKind;
  typeAnnotation: K.FlowTypeKind;
  optional: boolean;
}

export interface TypeParameterDeclaration {
  type: "TypeParameterDeclaration";
  params: K.TypeParameterKind[];
}

export interface ArrayTypeAnnotation {
  type: "ArrayTypeAnnotation";
  elementType: K.FlowTypeKind;
}

export interface ObjectTypeAnnotation {
  type: "ObjectTypeAnnotation";
  properties: (K.ObjectTypePropertyKind | K.ObjectTypeSpreadPropertyKind)[];
  indexers: K.ObjectTypeIndexerKind[];
  callProperties: K.ObjectTypeCallPropertyKind[];
  exact: boolean;
}

export interface ObjectTypeProperty {
  type: "ObjectTypeProperty";
  key: K.LiteralKind | K.IdentifierKind;
  value: K.FlowTypeKind;
  optional: boolean;
  variance?: K.VarianceKind | "plus" | "minus" | null;
}

export interface ObjectTypeSpreadProperty {
  type: "ObjectTypeSpreadProperty";
  argument: K.FlowTypeKind;
}

export interface ObjectTypeIndexer {
  type: "ObjectTypeIndexer";
  id: K.IdentifierKind;
  key: K.FlowTypeKind;
  value: K.FlowTypeKind;
  variance?: K.VarianceKind | "plus" | "minus" | null;
}

export interface ObjectTypeCallProperty {
  type: "ObjectTypeCallProperty";
  value: K.FunctionTypeAnnotationKind;
  static: boolean;
}

export interface Variance {
  type: "Variance";
  kind: "plus" | "minus";
}

export interface QualifiedTypeIdentifier {
  type: "QualifiedTypeIdentifier";
  qualification: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
  id: K.IdentifierKind;
}

export interface GenericTypeAnnotation {
  type: "GenericTypeAnnotation";
  id: K.IdentifierKind | K.QualifiedTypeIdentifierKind;
  typeParameters?: K.TypeParameterInstantiationKind | null;
}

export interface TypeParameterInstantiation {
  type: "TypeParameterInstantiation";
  params: K.FlowTypeKind[];
}

export interface MemberTypeAnnotation {
  type: "MemberTypeAnnotation";
  object: K.IdentifierKind;
  property: K.MemberTypeAnnotationKind | K.GenericTypeAnnotationKind;
}

export interface UnionTypeAnnotation {
  type: "UnionTypeAnnotation";
  types: K.FlowTypeKind[];
}

export interface IntersectionTypeAnnotation {
  type: "IntersectionTypeAnnotation";
  types: K.FlowTypeKind[];
}

export interface TypeofTypeAnnotation {
  type: "TypeofTypeAnnotation";
  argument: K.FlowTypeKind;
}

export interface TypeParameter {
  type: "TypeParameter";
  name: string;
  variance?: K.VarianceKind | "plus" | "minus" | null;
  bound?: K.TypeAnnotationKind | null;
}

export interface ClassImplements {
  type: "ClassImplements";
  id: K.IdentifierKind;
  superClass?: K.ExpressionKind | null;
  typeParameters?: K.TypeParameterInstantiationKind | null;
}

export interface InterfaceDeclaration {
  type: "InterfaceDeclaration";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  body: K.ObjectTypeAnnotationKind;
  extends: K.InterfaceExtendsKind[];
}

export interface InterfaceExtends {
  type: "InterfaceExtends";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterInstantiationKind | null;
}

export interface DeclareInterface {
  type: "DeclareInterface";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  body: K.ObjectTypeAnnotationKind;
  extends: K.InterfaceExtendsKind[];
}

export interface TypeAlias {
  type: "TypeAlias";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  right: K.FlowTypeKind;
}

export interface OpaqueType {
  type: "OpaqueType";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  implType: K.FlowTypeKind;
  superType: K.FlowTypeKind;
}

export interface DeclareTypeAlias {
  type: "DeclareTypeAlias";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  right: K.FlowTypeKind;
}

export interface DeclareOpaqueType {
  type: "DeclareOpaqueType";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  right: K.FlowTypeKind;
}

export interface TypeCastExpression {
  type: "TypeCastExpression";
  expression: K.ExpressionKind;
  typeAnnotation: K.TypeAnnotationKind;
}

export interface TupleTypeAnnotation {
  type: "TupleTypeAnnotation";
  types: K.FlowTypeKind[];
}

export interface DeclareVariable {
  type: "DeclareVariable";
  id: K.IdentifierKind;
}

export interface DeclareFunction {
  type: "DeclareFunction";
  id: K.IdentifierKind;
}

export interface DeclareClass {
  type: "DeclareClass";
  id: K.IdentifierKind;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  body: K.ObjectTypeAnnotationKind;
  extends: K.InterfaceExtendsKind[];
}

export interface DeclareModule {
  type: "DeclareModule";
  id: K.IdentifierKind | K.LiteralKind;
  body: K.BlockStatementKind;
}

export interface DeclareModuleExports {
  type: "DeclareModuleExports";
  typeAnnotation: K.TypeAnnotationKind;
}

export interface DeclareExportDeclaration {
  type: "DeclareExportDeclaration";
  default: boolean;
  declaration?: K.DeclareVariableKind | K.DeclareFunctionKind | K.DeclareClassKind | K.FlowTypeKind | null;
  specifiers: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
  source?: K.LiteralKind | null;
}

export interface ExportSpecifier {
  type: "ExportSpecifier";
  local?: K.IdentifierKind | null;
  id?: K.IdentifierKind | null;
  name?: K.IdentifierKind | null;
  exported: K.IdentifierKind;
}

export interface ExportBatchSpecifier {
  type: "ExportBatchSpecifier";
}

export interface DeclareExportAllDeclaration {
  type: "DeclareExportAllDeclaration";
  source?: K.LiteralKind | null;
}

export interface FlowPredicate {
  type: "FlowPredicate";
}

export interface InferredPredicate {
  type: "InferredPredicate";
}

export interface DeclaredPredicate {
  type: "DeclaredPredicate";
  value: K.ExpressionKind;
}

export interface ExportDeclaration {
  type: "ExportDeclaration";
  default: boolean;
  declaration?: K.DeclarationKind | K.ExpressionKind | null;
  specifiers: (K.ExportSpecifierKind | K.ExportBatchSpecifierKind)[];
  source?: K.LiteralKind | null;
}

export interface Block {
  value: string;
  leading: boolean;
  trailing: boolean;
  type: "Block";
}

export interface Line {
  value: string;
  leading: boolean;
  trailing: boolean;
  type: "Line";
}

export interface Noop {
  type: "Noop";
}

export interface DoExpression {
  type: "DoExpression";
  body: K.StatementKind[];
}

export interface Super {
  type: "Super";
}

export interface BindExpression {
  type: "BindExpression";
  object?: K.ExpressionKind | null;
  callee: K.ExpressionKind;
}

export interface Decorator {
  type: "Decorator";
  expression: K.ExpressionKind;
}

export interface MetaProperty {
  type: "MetaProperty";
  meta: K.IdentifierKind;
  property: K.IdentifierKind;
}

export interface ParenthesizedExpression {
  type: "ParenthesizedExpression";
  expression: K.ExpressionKind;
}

export interface ExportDefaultDeclaration {
  type: "ExportDefaultDeclaration";
  declaration: K.DeclarationKind | K.ExpressionKind;
}

export interface ExportNamedDeclaration {
  type: "ExportNamedDeclaration";
  declaration?: K.DeclarationKind | null;
  specifiers: K.ExportSpecifierKind[];
  source?: K.LiteralKind | null;
}

export interface ExportNamespaceSpecifier {
  type: "ExportNamespaceSpecifier";
  exported: K.IdentifierKind;
}

export interface ExportDefaultSpecifier {
  type: "ExportDefaultSpecifier";
  exported: K.IdentifierKind;
}

export interface ExportAllDeclaration {
  type: "ExportAllDeclaration";
  exported?: K.IdentifierKind | null;
  source: K.LiteralKind;
}

export interface CommentBlock {
  value: string;
  leading: boolean;
  trailing: boolean;
  type: "CommentBlock";
}

export interface CommentLine {
  value: string;
  leading: boolean;
  trailing: boolean;
  type: "CommentLine";
}

export interface Directive {
  type: "Directive";
  value: K.DirectiveLiteralKind;
}

export interface DirectiveLiteral {
  type: "DirectiveLiteral";
  value: string;
}

export interface StringLiteral {
  type: "StringLiteral";
  value: string;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
}

export interface NumericLiteral {
  type: "NumericLiteral";
  value: number;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
  raw?: string | null;
  extra: {
    "rawValue": number,
    "raw": string
  };
}

export interface BigIntLiteral {
  type: "BigIntLiteral";
  value: string | number;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
  extra: {
    "rawValue": string,
    "raw": string
  };
}

export interface NullLiteral {
  type: "NullLiteral";
  value?: null;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
}

export interface BooleanLiteral {
  type: "BooleanLiteral";
  value: boolean;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
}

export interface RegExpLiteral {
  type: "RegExpLiteral";
  value: RegExp;
  regex?: {
    "pattern": string,
    "flags": string
  } | null;
  pattern: string;
  flags: string;
}

export interface ObjectMethod {
  type: "ObjectMethod";
  id?: K.IdentifierKind | null;
  params: K.PatternKind[];
  body: K.BlockStatementKind;
  generator: boolean;
  expression: boolean;
  defaults: (K.ExpressionKind | null)[];
  rest?: K.IdentifierKind | null;
  async: boolean;
  returnType?: K.TypeAnnotationKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  kind: "method" | "get" | "set";
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
  computed: boolean;
  accessibility?: K.LiteralKind | null;
  decorators?: K.DecoratorKind[] | null;
}

export interface ObjectProperty {
  type: "ObjectProperty";
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
  value: K.ExpressionKind | K.PatternKind;
  accessibility?: K.LiteralKind | null;
  computed: boolean;
}

export interface ClassMethod {
  type: "ClassMethod";
  id?: K.IdentifierKind | null;
  params: K.PatternKind[];
  body: K.BlockStatementKind;
  generator: boolean;
  expression: boolean;
  defaults: (K.ExpressionKind | null)[];
  rest?: K.IdentifierKind | null;
  async: boolean;
  returnType?: K.TypeAnnotationKind | null;
  typeParameters?: K.TypeParameterDeclarationKind | null;
  kind: "get" | "set" | "method" | "constructor";
  key: K.LiteralKind | K.IdentifierKind | K.ExpressionKind;
  computed: boolean;
  static: boolean;
  decorators?: K.DecoratorKind[] | null;
}

export interface RestProperty {
  type: "RestProperty";
  argument: K.ExpressionKind;
}

export interface ForAwaitStatement {
  type: "ForAwaitStatement";
  left: K.VariableDeclarationKind | K.ExpressionKind;
  right: K.ExpressionKind;
  body: K.StatementKind;
}

export interface Import {
  type: "Import";
}

export interface TSType {
  type: "TSType";
}

export interface TSQualifiedName {
  type: "TSQualifiedName";
  left: K.IdentifierKind | K.TSQualifiedNameKind;
  right: K.IdentifierKind | K.TSQualifiedNameKind;
}

export interface TSTypeReference {
  type: "TSTypeReference";
  typeName: K.IdentifierKind | K.TSQualifiedNameKind;
  typeParameters?: K.TSTypeParameterInstantiationKind | null;
}

export interface TSTypeParameterInstantiation {
  type: "TSTypeParameterInstantiation";
  params: K.TSTypeKind[];
}

export interface TSHasOptionalTypeParameters {
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
}

export interface TSTypeParameterDeclaration {
  type: "TSTypeParameterDeclaration";
  params: K.TSTypeParameterKind[];
}

export interface TSHasOptionalTypeAnnotation {
  typeAnnotation?: K.TSTypeAnnotationKind | null;
}

export interface TSAsExpression {
  type: "TSAsExpression";
  expression: K.ExpressionKind;
  typeAnnotation: K.TSTypeKind;
  extra?: {
    "parenthesized": boolean
  } | null;
}

export interface TSNonNullExpression {
  type: "TSNonNullExpression";
  expression: K.ExpressionKind;
}

export interface TSAnyKeyword {
  type: "TSAnyKeyword";
}

export interface TSBooleanKeyword {
  type: "TSBooleanKeyword";
}

export interface TSNeverKeyword {
  type: "TSNeverKeyword";
}

export interface TSNullKeyword {
  type: "TSNullKeyword";
}

export interface TSNumberKeyword {
  type: "TSNumberKeyword";
}

export interface TSObjectKeyword {
  type: "TSObjectKeyword";
}

export interface TSStringKeyword {
  type: "TSStringKeyword";
}

export interface TSSymbolKeyword {
  type: "TSSymbolKeyword";
}

export interface TSUndefinedKeyword {
  type: "TSUndefinedKeyword";
}

export interface TSUnknownKeyword {
  type: "TSUnknownKeyword";
}

export interface TSVoidKeyword {
  type: "TSVoidKeyword";
}

export interface TSThisType {
  type: "TSThisType";
}

export interface TSArrayType {
  type: "TSArrayType";
  elementType: K.TSTypeKind;
}

export interface TSLiteralType {
  type: "TSLiteralType";
  literal: K.NumericLiteralKind | K.StringLiteralKind | K.BooleanLiteralKind;
}

export interface TSUnionType {
  type: "TSUnionType";
  types: K.TSTypeKind[];
}

export interface TSIntersectionType {
  type: "TSIntersectionType";
  types: K.TSTypeKind[];
}

export interface TSConditionalType {
  type: "TSConditionalType";
  checkType: K.TSTypeKind;
  extendsType: K.TSTypeKind;
  trueType: K.TSTypeKind;
  falseType: K.TSTypeKind;
}

export interface TSInferType {
  type: "TSInferType";
  typeParameter: K.TSTypeParameterKind;
}

export interface TSTypeParameter {
  type: "TSTypeParameter";
  name: string;
  optional: boolean;
  typeAnnotation?: K.TypeAnnotationKind | K.TSTypeAnnotationKind | null;
  constraint?: K.TSTypeKind | null;
  default?: K.TSTypeKind | null;
}

export interface TSParenthesizedType {
  type: "TSParenthesizedType";
  typeAnnotation: K.TSTypeKind;
}

export interface TSFunctionType {
  type: "TSFunctionType";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  typeAnnotation?: K.TSTypeAnnotationKind | null;
  parameters: (K.IdentifierKind | K.RestElementKind)[];
}

export interface TSConstructorType {
  type: "TSConstructorType";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  typeAnnotation?: K.TSTypeAnnotationKind | null;
  parameters: (K.IdentifierKind | K.RestElementKind)[];
}

export interface TSDeclareFunction {
  type: "TSDeclareFunction";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  declare: boolean;
  async: boolean;
  generator: boolean;
  id?: K.IdentifierKind | null;
  params: K.PatternKind[];
  returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
}

export interface TSDeclareMethod {
  type: "TSDeclareMethod";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  async: boolean;
  generator: boolean;
  params: K.PatternKind[];
  abstract: boolean;
  accessibility: "public" | "private" | "protected" | "undefined";
  static: boolean;
  computed: boolean;
  optional: boolean;
  key: K.IdentifierKind | K.StringLiteralKind | K.NumericLiteralKind | K.ExpressionKind;
  kind: "get" | "set" | "method" | "constructor";
  access: "public" | "private" | "protected" | "undefined";
  decorators?: K.DecoratorKind[] | null;
  returnType?: K.TSTypeAnnotationKind | K.NoopKind | null;
}

export interface TSMappedType {
  type: "TSMappedType";
  readonly: boolean;
  typeParameter: K.TSTypeParameterKind;
  optional: boolean;
  typeAnnotation?: K.TSTypeKind | null;
}

export interface TSTupleType {
  type: "TSTupleType";
  elementTypes: K.TSTypeKind[];
}

export interface TSRestType {
  type: "TSRestType";
  typeAnnotation: K.TSTypeKind;
}

export interface TSOptionalType {
  type: "TSOptionalType";
  typeAnnotation: K.TSTypeKind;
}

export interface TSIndexedAccessType {
  type: "TSIndexedAccessType";
  objectType: K.TSTypeKind;
  indexType: K.TSTypeKind;
}

export interface TSTypeOperator {
  type: "TSTypeOperator";
  operator: string;
  typeAnnotation: K.TSTypeKind;
}

export interface TSIndexSignature {
  type: "TSIndexSignature";
  typeAnnotation?: K.TSTypeAnnotationKind | null;
  parameters: K.IdentifierKind[];
  readonly: boolean;
}

export interface TSPropertySignature {
  type: "TSPropertySignature";
  typeAnnotation?: K.TSTypeAnnotationKind | null;
  key: K.ExpressionKind;
  computed: boolean;
  readonly: boolean;
  optional: boolean;
  initializer?: K.ExpressionKind | null;
}

export interface TSMethodSignature {
  type: "TSMethodSignature";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  typeAnnotation?: K.TSTypeAnnotationKind | null;
  key: K.ExpressionKind;
  computed: boolean;
  optional: boolean;
  parameters: (K.IdentifierKind | K.RestElementKind)[];
}

export interface TSTypePredicate {
  type: "TSTypePredicate";
  typeAnnotation: K.TSTypeAnnotationKind;
  parameterName: K.IdentifierKind | K.TSThisTypeKind;
}

export interface TSCallSignatureDeclaration {
  type: "TSCallSignatureDeclaration";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  typeAnnotation?: K.TSTypeAnnotationKind | null;
  parameters: (K.IdentifierKind | K.RestElementKind)[];
}

export interface TSConstructSignatureDeclaration {
  type: "TSConstructSignatureDeclaration";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  typeAnnotation?: K.TSTypeAnnotationKind | null;
  parameters: (K.IdentifierKind | K.RestElementKind)[];
}

export interface TSEnumMember {
  type: "TSEnumMember";
  id: K.IdentifierKind | K.StringLiteralKind;
  initializer?: K.ExpressionKind | null;
}

export interface TSTypeQuery {
  type: "TSTypeQuery";
  exprName: K.IdentifierKind;
}

export interface TSTypeLiteral {
  type: "TSTypeLiteral";
  members: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
}

export interface TSTypeAssertion {
  type: "TSTypeAssertion";
  typeAnnotation: K.TSTypeKind;
  expression: K.ExpressionKind;
  extra?: {
    "parenthesized": boolean
  } | null;
}

export interface TSEnumDeclaration {
  type: "TSEnumDeclaration";
  id: K.IdentifierKind;
  const: boolean;
  declare: boolean;
  members: K.TSEnumMemberKind[];
  initializer?: K.ExpressionKind | null;
}

export interface TSTypeAliasDeclaration {
  type: "TSTypeAliasDeclaration";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  id: K.IdentifierKind;
  declare: boolean;
  typeAnnotation: K.TSTypeKind;
}

export interface TSModuleBlock {
  type: "TSModuleBlock";
  body: K.StatementKind[];
}

export interface TSModuleDeclaration {
  type: "TSModuleDeclaration";
  id: K.StringLiteralKind | K.IdentifierKind | K.TSQualifiedNameKind;
  declare: boolean;
  global: boolean;
  body?: K.TSModuleBlockKind | K.TSModuleDeclarationKind | null;
}

export interface TSImportEqualsDeclaration {
  type: "TSImportEqualsDeclaration";
  id: K.IdentifierKind;
  isExport: boolean;
  moduleReference: K.IdentifierKind | K.TSQualifiedNameKind | K.TSExternalModuleReferenceKind;
}

export interface TSExternalModuleReference {
  type: "TSExternalModuleReference";
  expression: K.StringLiteralKind;
}

export interface TSExportAssignment {
  type: "TSExportAssignment";
  expression: K.ExpressionKind;
}

export interface TSNamespaceExportDeclaration {
  type: "TSNamespaceExportDeclaration";
  id: K.IdentifierKind;
}

export interface TSInterfaceBody {
  type: "TSInterfaceBody";
  body: (K.TSCallSignatureDeclarationKind | K.TSConstructSignatureDeclarationKind | K.TSIndexSignatureKind | K.TSMethodSignatureKind | K.TSPropertySignatureKind)[];
}

export interface TSExpressionWithTypeArguments {
  type: "TSExpressionWithTypeArguments";
  expression: K.IdentifierKind | K.TSQualifiedNameKind;
  typeParameters?: K.TSTypeParameterInstantiationKind | null;
}

export interface TSInterfaceDeclaration {
  type: "TSInterfaceDeclaration";
  typeParameters?: K.TSTypeParameterDeclarationKind | null;
  id: K.IdentifierKind | K.TSQualifiedNameKind;
  declare: boolean;
  extends?: K.TSExpressionWithTypeArgumentsKind[] | null;
  body: K.TSInterfaceBodyKind;
}

export interface TSParameterProperty {
  type: "TSParameterProperty";
  accessibility: "public" | "private" | "protected" | "undefined";
  readonly: boolean;
  parameter: K.IdentifierKind | K.AssignmentPatternKind;
}

export interface OptionalMemberExpression {
  type: "OptionalMemberExpression";
  object: K.ExpressionKind;
  property: K.IdentifierKind | K.ExpressionKind;
  computed: boolean;
  optional: boolean;
}

export interface OptionalCallExpression {
  type: "OptionalCallExpression";
  callee: K.ExpressionKind;
  arguments: (K.ExpressionKind | K.SpreadElementKind)[];
  optional: boolean;
}